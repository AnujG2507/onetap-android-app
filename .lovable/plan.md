
# Fix: Native Checklist Viewer — Checkboxes & Height (Final Thorough Fix)

## Exact Bugs Found (After Full Code Read)

### Bug 1 — Double-Toggle from Conflicting Click Handlers (Checkboxes Appear Unresponsive)

In the current HTML generated by `buildHtml`, the checkbox input has:
```html
<input type="checkbox" ... onclick="event.stopPropagation()">
```
And the parent `.ci` div has:
```html
<div class="ci" id="ci0" onclick="onCheck(0)">
```

When the user taps anywhere on the row:
1. The `.ci` div's `onclick` fires → `onCheck(i)` → `cb.checked = !cb.checked` (now `true`)
2. The native `<input>` also receives the same tap and fires its own click → `event.stopPropagation()` → but the browser already toggled `cb.checked` back to `false` **natively before JS ran**

Net result: the checkbox visually flickers but ends at the same state. This is why checkboxes appear completely unresponsive.

**Fix:** Set `pointer-events: none` directly in CSS on the input (already partially done in CSS but `onclick` still fires), AND remove `onclick="event.stopPropagation()"` from the input entirely. The input must be a pure visual element with zero JS and zero pointer events. Only the div's `onclick` must run.

Additionally, wrap `onCheck` with a debounce flag to prevent any race between touch events:
```js
var _checking = false;
function onCheck(i) {
  if (_checking) return;
  _checking = true;
  // ... toggle logic ...
  setTimeout(function(){ _checking = false; }, 300);
}
```

### Bug 2 — `document.body.scrollHeight` Returns Container Height, Not Content Height

When the WebView is initialized with `height = 72% of screen`, `document.body.scrollHeight` returns the **body's scroll height which equals the WebView viewport height** (not the actual content height), because the `body` expands to fill the container. The `#content` div's actual rendered height is what we need.

**Fix:** Measure the `#content` div's `offsetHeight` instead:
```js
"(function(){ return document.getElementById('content').offsetHeight; })()"
```
This returns the true rendered height of the content div regardless of the WebView container size.

### Bug 3 — Dialog Height Cap at 72% for Both Initial and Final Heights

The initial height of `72% * dm.heightPixels` is given to the WebView so the dialog has a starting size. But `onPageFinished` then measures "content height" and caps it at `72%` again — so if content is taller than 72%, it stays at 72% with no internal scroll. If content is shorter, it *should* shrink, but Bug 2 above means it never detects the true content height.

The correct flow must be:
1. Start WebView at `75%` of screen (max allowed per the user's requirement)
2. After `onPageFinished`, measure `#content div's offsetHeight`
3. Set final WebView height = `min(contentHeight + padding, 75% of screen)`
4. Call `dialog.getWindow().setLayout(MATCH_PARENT, WRAP_CONTENT)` to force re-measure

### Bug 4 — `MessageChooserDialog` Style Has No `windowMaxHeight` Override

The parent `Theme.Material.Light.Dialog` internally constrains dialog height. While `setLayout(MATCH_PARENT, WRAP_CONTENT)` is called, the style's implicit `windowMaxHeight` (typically 80% or less of screen) can still clamp the content. We need to set `android:windowMaxHeight` explicitly in the style, or better: switch the dialog to `MATCH_PARENT` height and use the WebView's measured height as the scroll container height.

**Best fix for height:** Instead of relying on `WRAP_CONTENT` window layout (which fights with the theme), give the dialog a **fixed height of 75% of screen** using `setLayout(MATCH_PARENT, fixedHeight)` where `fixedHeight = 75% of dm.heightPixels`. Then inside, the WebView scrolls internally. This is reliable and predictable.

---

## Solution

### File: `native/android/app/src/main/java/app/onetap/access/TextProxyActivity.java`

**Change 1 — Fix WebView initial height and onPageFinished logic:**

- Set initial height to `75%` of screen height (matching user requirement)
- In `onPageFinished`, query `#content` div's `offsetHeight` (not `body.scrollHeight`)
- Apply final height = `min(contentHeight + topPadding + bottomPadding, 75% screen)`
- Set `dialog.getWindow().setLayout(MATCH_PARENT, fixedDialogHeight)` where `fixedDialogHeight` is the pre-calculated 75% of screen minus header/footer heights

**Change 2 — Fix the checkbox double-toggle:**

Remove `onclick="event.stopPropagation()"` from the `<input>` element. The input already has `pointer-events:none` in CSS — that's the correct way to block input interaction. The `onclick` attribute on the input creates a second event handler that fights with the div's handler.

Updated input HTML (no onclick attribute at all):
```java
html += '<input type="checkbox" id="cb'+i+'"'+(checked?' checked':'')+'>'; 
// No onclick — pointer-events:none in CSS already blocks all input interaction
```

**Change 3 — Add debounce guard to `onCheck`:**

```js
var _busy = false;
function onCheck(i) {
  if(_busy) return;
  _busy = true;
  var cb = document.getElementById('cb'+i);
  var item = document.getElementById('ci'+i);
  if(!cb || !item){ _busy=false; return; }
  cb.checked = !cb.checked;
  var checked = cb.checked;
  var key = 'chk_<sid>_' + i;
  savedState[key] = checked;
  item.className = 'ci' + (checked ? ' done' : '');
  if(window.Android && Android.saveCheckboxState) Android.saveCheckboxState(key, checked);
  setTimeout(function(){ _busy = false; }, 250);
}
```

**Change 4 — Fix height measurement to use `#content` offsetHeight:**

```java
view.evaluateJavascript(
    "(function(){ var el=document.getElementById('content'); return el ? el.offsetHeight : document.body.scrollHeight; })()",
    value -> {
        try {
            int contentPx = Integer.parseInt(value.trim());
            int maxPx = (int)(dm.heightPixels * 0.75f);
            // Add body padding (16px top + 24px bottom = 40px = ~40dp)
            int finalHeight = Math.min(contentPx + dpToPx(40), maxPx);
            runOnUiThread(() -> {
                ViewGroup.LayoutParams lp = webView.getLayoutParams();
                lp.height = finalHeight;
                webView.setLayoutParams(lp);
                if (dialog != null && dialog.getWindow() != null) {
                    dialog.getWindow().setLayout(
                        ViewGroup.LayoutParams.MATCH_PARENT,
                        ViewGroup.LayoutParams.WRAP_CONTENT
                    );
                }
            });
        } catch (Exception e) {
            Log.w(TAG, "scrollHeight parse failed: " + value);
        }
    }
);
```

**Change 5 — Fix the `onContentHeight` bridge fallback too** (same `#content` measurement issue):

Update the `window.addEventListener('load', ...)` in the HTML to use `#content` offsetHeight:
```js
window.addEventListener('load', function(){
  if(window.Android && Android.onContentHeight){
    var el = document.getElementById('content');
    Android.onContentHeight(el ? el.offsetHeight : document.body.scrollHeight);
  }
});
```

---

## Summary of All Changes

| # | Bug | Root Cause | Fix |
|---|---|---|---|
| 1 | Checkboxes don't toggle | `onclick="event.stopPropagation()"` on input double-fires, cancelling toggle | Remove `onclick` from input; rely on CSS `pointer-events:none` only |
| 2 | Only 2 of 4 items visible | `body.scrollHeight` = container height not content height | Measure `#content div.offsetHeight` instead |
| 3 | Dialog height too small | 72% initial height not adjusting down + wrong measurement | Use `#content.offsetHeight`, cap at 75%, add body padding to measurement |
| 4 | Height never shrinks for short content | Same measurement bug | Fixed by using `offsetHeight` of content div |

**File changed:** `native/android/app/src/main/java/app/onetap/access/TextProxyActivity.java` only.
